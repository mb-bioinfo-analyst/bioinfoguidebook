{
  "hash": "2eb1e21b9806536faf2c3c549756636e",
  "result": {
    "markdown": "---\ntitle: \"Unveiling Data Insights with Principal Component Analysis (PCA) in R\"\nauthor: \"Bilal Mustafa\"\ndate: \"2023-09-24\"\ncategories: [R, PCA, Feature Engineering, Dimentionality Reduction]\nimage: \"image.jpg\"\nexecute: \n  output: true\n  echo: fenced\n  warning: false\n  error: false\nformat:\n  html:\n    code-link: true\n    df-print: paged\n    code-copy: true\n---\n\n\n## Introduction:\n\nThe dimensionality reduction method known as Principal Component Analysis (PCA) is popular in the fields of data analysis and machine learning.\nIt is a mathematical technique that aids in the simplification of complicated datasets while retaining the majority of the crucial details.\nIn order to achieve this, PCA converts the initial data into a new coordinate system, known as the principle components, where the axes are linear combinations of the initial variables.\n\n------------------------------------------------------------------------\n\n# Basic Concepts\n\n## Data Preparation\n\nYou normally begin with a dataset that comprises numerous variables or features before applying PCA.\nThese traits, measures, or characteristics of the data points you're evaluating could be considered as these features.\nFor each characteristic to have a mean of 0 and a standard deviation of 1, your data must be standardized or normalized.\nThis stage makes sure that each feature is given the same weight in the analysis.\n\n------------------------------------------------------------------------\n\n## Covariance Matrix\n\nThe covariance matrix of the standardized data is computed first in PCA.\nThe associations between each pair of variables in your dataset are summarized in the covariance matrix.\nIt explains how variables move in tandem or in opposition to one another.\nWhile a negative covariance suggests they move in the opposite directions, a positive covariance shows that two variables rise or fall together.\n\n------------------------------------------------------------------------\n\n## Eigenvalues and Eigenvectors\n\nThe next step in PCA is to compute the eigenvalues and eigenvectors of the covariance matrix.\n\n-   **Eigenvalues**: The magnitude of variance along each principal component is shown by these scalar values.\n    Higher eigenvalues correspond to principal components that capture more variance in the data.\n    Eigenvalues are sorted in descending order.\n\n-   **Eigenvectors**: In the original feature space, these are the directions or vectors where data fluctuates the most.\n    Each eigenvector corresponds to a principal component.\n\n------------------------------------------------------------------------\n\n## Principal Components\n\nThe principal components are linear combinations of the original features.\nEach principal component is formed by multiplying each feature by a weight (the corresponding eigenvector) and summing these weighted values.\n\nThe first principal component (PC1), followed by PC2, PC3, and so on, explains the most variance in the data.\nEach following component collects less information than PC1, yet they are orthogonal (uncorrelated) to each other, indicating that they are not redundant.\n\n------------------------------------------------------------------------\n\n## Explained Variance Ratio\n\nThe explained variance ratio can be used to determine how much variance each principal component captures.\nIt indicates how much of the total variation in the data is explained by each major component.\nA cumulative explained variance plot is typically used to determine how many principal components to keep.\n\n------------------------------------------------------------------------\n\n## Dimensionality Reduction\n\nYou can decide how many principal components to keep based on the cumulative explained variance and your desired degree of kept information (for example, retaining 95% of the variance).\nData analysis, visualization, and modeling can be made simpler by reducing the number of dimensions by eliminating less significant elements/components.\n\n------------------------------------------------------------------------\n\n## Reconstruction\n\nYou can use the retained principal components to project your data back into the original feature space if you choose to reduce the dimensionality.\nThis helps you analyze the findings in light of your original data.\n\n------------------------------------------------------------------------\n\n## Applications\n\nPCA is used in various fields, including:\n\n-   **Data Visualization**: Reducing high-dimensional data to two or three dimensions for visualization purposes.\n-   **Noise Reduction**: Removing noise and redundancy in data.\n-   **Feature Engineering**: Creating new features that capture the most important information.\n-   **Machine Learning**: Reducing the number of features in machine learning models to improve performance and reduce overfitting.\n\n------------------------------------------------------------------------\n\n## Takeaway Note\n\nIn summary, PCA is a potent method for dimensionality reduction that enables you to better understand your data by changing it into a form that is easier to read.\nIt is frequently used in machine learning and data analysis to streamline complex datasets and make them easier to handle for additional/downstream analysis.\n\n------------------------------------------------------------------------\n\n# Practical Example: PCA in R\n\nWe'll use a sample dataset to illustrate the process, but you can apply PCA to your own data with similar steps.\n\n### Step 1: Load and Preprocess Data\n\nIn this example, we'll use the built-in \"iris\" dataset in R.\nHowever, for your real-world projects, you should load your data into a dataframe and preprocess it, including scaling if necessary.\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n# Load the iris dataset\ndata(iris)\n\n# Extract the features\nfeatures <- iris[, 1:4]\n\n# Standardize the features (mean=0, variance=1)\nscaled_features <- scale(features)\n```\n````\n:::\n\n\n\nIn the histograms presented below, we aim to illustrate the fundamental differences between the original features and the scaled features of the Iris dataset. These visualizations are valuable for understanding the effects of standardization (mean = 0, variance = 1) on the distribution of data.\n\n**Feature Distribution (Original Features)**    \n\n- Feature 1 (Sepal Length): In the histogram for the original sepal length feature, we observe that the data is distributed across a relatively wide range of values. The distribution appears somewhat skewed, with a majority of data points clustered towards the center.\n\n- Feature 2 (Sepal Width): The original sepal width feature exhibits a distribution that appears approximately normal, with data points spread somewhat evenly across its range.\n\n- Feature 3 (Petal Length): The petal length feature's histogram indicates a clear bimodal distribution, with two distinct peaks in the data. This suggests that there may be two subpopulations within this feature.\n\n- Feature 4 (Petal Width): The petal width feature, like petal length, also displays a bimodal distribution, albeit with slightly different characteristics. These two peaks could signify different categories of data within this feature.\n\n**Scaled Feature Distribution (After Standardization)**   \nAfter standardizing the features to have a mean of 0 and a variance of 1, we observe the following changes:   \n\n- Scaled Feature 1 (Sepal Length): Standardization has shifted the distribution to have a mean of 0 and a unit variance. The data is now centered around 0, and the scale has been adjusted accordingly.\n\n- Scaled Feature 2 (Sepal Width): Similar to sepal length, standardization has centered the distribution around 0 and rescaled the data. It maintains the approximate normality seen in the original feature.\n\n- Scaled Feature 3 (Petal Length): Standardization retains the bimodal nature of the distribution, but the data now adheres to a mean of 0 and unit variance. This transformation makes it easier to compare with other features.\n\n- Scaled Feature 4 (Petal Width): Standardization has the same effect on petal width as on petal length. The bimodal distribution is preserved, but the data is now on the same scale as the other features.    \n\nThese visualizations highlight the impact of standardization on the distribution of data. It's essential to standardize data before applying certain statistical techniques like Principal Component Analysis (PCA) to ensure that each feature contributes fairly to the analysis, regardless of its original scale or magnitude. By standardizing the features, we bring them to a common scale and remove the influence of the mean and variance, making them directly comparable and suitable for techniques like PCA.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Feature vs. Scaled Feature Distribution](index_files/figure-html/unnamed-chunk-2-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n### Step 2: Perform PCA\n\nNow, let's perform PCA on our standardized data.\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n# Perform PCA\npca_result <- prcomp(scaled_features)\n```\n````\n:::\n\n\n### Step 3: Analyze Results\n\nYou can now explore the results of the PCA, such as the variance explained by each principal component and their contributions.\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n# Variance explained by each principal component\nvariance_explained <- pca_result$sdev^2 / sum(pca_result$sdev^2)\n\n# Plot the variance explained\nbarplot(variance_explained, names.arg = c(\"PC1\", \"PC2\", \"PC3\", \"PC4\"),\n        xlab = \"Principal Component\", ylab = \"Variance Explained\",\n        main = \"Variance Explained by Each Principal Component\")\n```\n````\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n### Step 4: Interpretation\n\nInterpret the results by considering the variance explained by each principal component.\nYou can choose a threshold (e.g., retaining 95% variance) to determine how many principal components to keep for further analysis.\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\nThe biplot above presents the data points projected onto the PC1 and PC2 axes, allowing you to observe the distribution of your data in this new two-dimensional space. Additionally, you'll see arrows indicating the contributions of the original features to PC1 and PC2. The length and direction of these arrows provide insights into which features have the most influence on each principal component.\n\n\n\n### Conclusion\n\nPrincipal Component Analysis (PCA) is a powerful technique for dimensionality reduction, noise reduction, and data visualization in data analysis.\nIn this blog post, we've explored the core concepts of PCA and provided a hands-on example using R.\nBy incorporating PCA into your data analysis toolkit, you can gain deeper insights from your high-dimensional datasets and make more informed decisions in your data-driven projects.\n\n------------------------------------------------------------------------\n\n## Packages used for PCA analysis in R\n\nHere's a table of some popular R packages commonly used for Principal Component Analysis (PCA) along with links to their respective documentation:\n\n| Package Name | Description                                                      | URL                                                                                                                                     |\n|:-------------|:-----------------|:---------------------------------------|\n| `prcomp`     | Part of the `stats` package, used for PCA.                       | [Documentation](https://stat.ethz.ch/R-manual/R-devel/library/stats/html/prcomp.html)                                                   |\n| `PCAtools`   | Comprehensive PCA toolkit with visualization and analysis tools. | [GitHub](https://github.com/kevinblighe/PCAtools) [bioconductor](https://www.bioconductor.org/packages/release/bioc/html/PCAtools.html) |\n| `FactoMineR` | Provides PCA, multiple correspondence analysis, and more.        | [CRAN](https://cran.r-project.org/package=FactoMineR)                                                                                   |\n| `ade4`       | Multivariate data analysis and graphical display.                | [CRAN](https://cran.r-project.org/package=ade4)                                                                                         |\n| `caret`      | General-purpose machine learning package with PCA support.       | [CRAN](https://cran.r-project.org/package=caret)                                                                                        |\n| `ggfortify`  | Enhances visualization of PCA results.                           | [CRAN](https://cran.r-project.org/package=ggfortify)                                                                                    |\n| `pcaPP`      | Principal component analysis with outlier detection.             | [CRAN](https://cran.r-project.org/package=pcaPP)                                                                                        |\n\n: R Packages for PCA Analysis\n\nPlease note that R packages are frequently updated, so it's a good practice to visit the package documentation links for the most up-to-date information on package usage and functionality.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\r\n<script src=\"../../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}